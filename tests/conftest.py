import os

import pytest
import sqlite3
import tempfile
import subprocess


# -------- For testing the `db_file_comparer.py` module --------


@pytest.fixture
def temp_db():
    """Fixture to create a temporary database file with specific content."""

    def _temp_db(schema, data):
        temp_db = tempfile.NamedTemporaryFile(delete=False)
        conn = sqlite3.connect(temp_db.name)
        cursor = conn.cursor()
        for table, create_statement in schema.items():
            cursor.execute(create_statement)
            for row in data.get(table, []):
                cursor.execute(
                    f"INSERT INTO {table} VALUES ({','.join('?' for _ in row)})",
                    row,
                )
        conn.commit()
        conn.close()
        return temp_db.name

    return _temp_db


# -------- For testing `tumorsphere tumorsphere are-dbs-equal` --------
# --------    (the CLI of the `db_file_comparer.py` module)    --------


@pytest.fixture(scope="session")
def run_cli():
    """Fixture to run a CLI command and return its output, error, and exit status."""

    def _run_cli(command, cwd=None):
        result = subprocess.run(
            command, capture_output=True, text=True, shell=True, cwd=cwd
        )
        return result.stdout.strip(), result.stderr.strip(), result.returncode

    return _run_cli


# -------- For testing the `tumorsphere simulate` command --------
# ---- (.db's generated by the test will have diferent simulation_start
# ---- values in the Cultures table, than the fixed versions in the
# ---- expected_outputs directory)


@pytest.fixture
def compare_dbs_ignore_timestamp():
    def _compare(db_path1, db_path2):
        return compare_databases_ignore_timestamp(db_path1, db_path2)

    return _compare


# ========================================
# ========== DB UTILS FUNCTIONS ==========
# ========================================


def compare_databases_ignore_timestamp(db_path1, db_path2):
    # Connect to both databases
    conn1 = sqlite3.connect(db_path1)
    conn2 = sqlite3.connect(db_path2)

    # Get the schema for both databases
    schema1 = conn1.execute(
        "SELECT name, sql FROM sqlite_master WHERE type='table' ORDER BY name"
    ).fetchall()
    schema2 = conn2.execute(
        "SELECT name, sql FROM sqlite_master WHERE type='table' ORDER BY name"
    ).fetchall()

    # Ensure schemas are identical (this check remains as it is unless you
    # also need to ignore schema differences related to the timestamp)
    if schema1 != schema2:
        print("Schemas are different.")
        return False

    # Iterate through each table and compare data, excluding simulation_start
    # from the Cultures table
    for table_name, _ in schema1:
        if table_name == "Cultures":
            query = "SELECT culture_id, prob_stem, prob_diff, culture_seed, adjacency_threshold, swap_probability FROM {} ORDER BY rowid".format(
                table_name
            )
        else:
            query = f"SELECT * FROM {table_name} ORDER BY rowid"

        rows1 = conn1.execute(query).fetchall()
        rows2 = conn2.execute(query).fetchall()

        if rows1 != rows2:
            print(f"Data in table {table_name} is different.")
            for i, (row1, row2) in enumerate(zip(rows1, rows2)):
                if row1 != row2:
                    print(
                        f"Row {i} is different:\n\tFirst DB: {row1}\n\tSecond DB: {row2}"
                    )
            return False

    print("Databases are equal.")
    return True
